/****************************************Copyright (c)**************************************************
**                              
**                                 
**                                  
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: M25P80.c
**创   建   人: 杨承凯
**创 建 日  期: 2011年3月23日
**最后修改日期: 2011年3月23日
**描        述: Flash源文件，在时钟频率为24.5MHz下测试没问题
********************************************************************************************************/
#define		_FLASH_C_

#include "includes.h"
#include "Disk.h"


#define NAND_DMA_ACCESS


//数据长度设置
#define DATALEN		NAND_PAGE_SIZE

//磁盘访问结构
#define DISK_READ	1
#define DISK_WRITE	2
#define DISK_ERASE	3
typedef struct _DiskParamS
{
	uint8	oper;
	uint8*  pData;
	uint32	addr;	
	uint32	len;
	OS_EVENT* pPendTask;
}DiskParamS;


//消息队列
#define DISK_MSG_COUNT		16
OS_EVENT* pDiskMsg = NULL;
INT8U	nDiskErr;
void*	arrDiskMsg[16];

//数据缓冲区
uint16  nDataLen = DATALEN;	 
uint8 xdata WriteBuff[DATALEN];
uint8 xdata NandBuff[DATALEN];
uint8 xdata TxBuff[DATALEN];
uint8 xdata RxBuff[DATALEN];

#ifdef NAND_DMA_ACCESS
static OS_EVENT 	*m_pNandDMASyncEvent = NULL;	//DMA同步事件
#endif


//内部函数声明
void FlashWrite(uint8* pdat,uint32 nStartAddr,uint32 nlen);
void FlashRead(uint8* pdat,uint32 nStartAddr,uint32 nlen);
void FlashErase(uint32 Addr, uint32 nLen);
BOOL FlashBusy(void);
BOOL IsFlashOpen(void);
void FlashCheck(void);


/****************************************************************************
* 名	称：FlashInit()
* 功	能：M25P80初始化函数
* 入口参数：无
* 出口参数：无
* 说	明：无
****************************************************************************/
#ifdef _DISK_INIT_
void DiskInit() reentrant
{
#ifdef NAND_DMA_ACCESS
	DMA_InitTypeDef  DMA_InitStructure;
#endif

    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
	FSMC_NAND_Init();

#ifdef NAND_DMA_ACCESS
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
	DMA_DeInit(DMA1_Channel1);
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)(Bank_NAND_ADDR | DATA_AREA);
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)NandBuff;
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
	DMA_InitStructure.DMA_BufferSize = DATALEN;
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
	DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;
	DMA_Init(DMA1_Channel1, &DMA_InitStructure);

	DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);    

#endif

}
#endif	 //_FLASH_INIT_


/****************************************************************************
* 名	称：FlashOpen()
* 功	能：M25P80打开
* 入口参数：无
* 出口参数：无
* 说	明：无
****************************************************************************/
void FlashOpen()
{
#ifdef NAND_DMA_ACCESS
	if(m_pNandDMASyncEvent == NULL) 
	{
		m_pNandDMASyncEvent = OSSemCreate(0);		 
	}
#endif

	if(pDiskMsg == NULL)
	{
		pDiskMsg = OSQCreate(arrDiskMsg, DISK_MSG_COUNT);
	}	
}

void DiskOpen(void)
{
	FlashOpen();
}

void DiskClose(void)
{

}

void DiskDisable(void)
{
	FSMC_NANDCmd(FSMC_Bank2_NAND, DISABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, DISABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, DISABLE);	
}

void DiskEnable(void)
{
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);	
	FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
}


//向磁盘写数据，由用户线程调用
uint8 DiskWrite(OS_EVENT* pPendTask, uint8* pData, uint32 nAddr, uint32 nLen)
{
	uint8 nErr;
	DiskParamS DiskParam;
	
	DiskParam.pPendTask = pPendTask;
	DiskParam.pData = pData;
	DiskParam.addr = nAddr;
	DiskParam.len = nLen;
	DiskParam.oper = DISK_WRITE;

	//给磁盘管理线程发送消息
	OSQPost(pDiskMsg, &DiskParam);

	//等待磁盘管理线程处理完成
	OSSemPend(pPendTask, 0, &nErr);
	
	//返回操作结果
	return nErr;
}

//从磁盘读数据，由用户线程调用
uint8 DiskRead(OS_EVENT* pPendTask, uint8* pData, uint32 nAddr, uint32 nLen)
{
	uint8 nErr;
	DiskParamS DiskParam;
	
	DiskParam.pPendTask = pPendTask;
	DiskParam.pData = pData;
	DiskParam.addr = nAddr;
	DiskParam.len = nLen;
	DiskParam.oper = DISK_READ;
	
	//给磁盘管理线程发送消息
	OSQPost(pDiskMsg, &DiskParam);
		
	//等待磁盘管理线程处理完成
	OSSemPend(pPendTask, 0, &nErr);
		
	//返回操作结果
	return nErr;
}

//擦除磁盘数据，由用户线程调用
uint8 DiskErase(OS_EVENT* pPendTask, uint32 nAddr, uint32 nLen)
{
	uint8 nErr;
	DiskParamS DiskParam;
	
	DiskParam.pPendTask = pPendTask;
	DiskParam.pData = NULL;
	DiskParam.addr = nAddr;
	DiskParam.len = nLen;
	DiskParam.oper = DISK_ERASE;
	
	//给磁盘管理线程发送消息
	OSQPost(pDiskMsg, &DiskParam);
		
	//等待磁盘管理线程处理完成
	OSSemPend(pPendTask, 0, &nErr);
		
	//返回操作结果
	return nErr;
}



void DiskProcess(void)
{
	DiskParamS* pDiskParam;

	pDiskParam = (DiskParamS*)OSQPend(pDiskMsg, 0, &nDiskErr);

	if(pDiskParam->oper == DISK_READ)
	{
		//读操作
		FlashRead(pDiskParam->pData, pDiskParam->addr, pDiskParam->len);
	}
	else if(pDiskParam->oper == DISK_WRITE)
	{
		//写操作
		FlashWrite(pDiskParam->pData, pDiskParam->addr, pDiskParam->len);

	}
	else if(pDiskParam->oper == DISK_ERASE)
	{
		//写操作
		FlashErase(pDiskParam->addr, pDiskParam->len);

	}

	//通知用户线程存取操作完成
	OSSemPost(pDiskParam->pPendTask);
}

/****************************************************************************
* 名	称：FlashClose()
* 功	能：M25P80关闭 
* 入口参数：无
* 出口参数：无
* 说	明：无
****************************************************************************/
#ifdef	_FALSE_CLOSE_
void FlashClose() reentrant
{
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, DISABLE);
}
#endif

/****************************************************************************
* 名	称：IsFlashOpen()
* 功	能：M25P80是否打开
* 入口参数：无
* 出口参数：TRUE：打开。
* 说	明：无
****************************************************************************/
#ifdef	_IS_FALSE_OPEN_
BOOL IsFlashOpen() reentrant
{
	return 0;
}
#endif


/****************************************************************************
* 名	称：DMA1_Channel4_IRQHandler		DMA1_Channel4_IRQn
* 功	能：DMA发送中断
* 入口参数：无
* 出口参数：无
* 说	明：DMA发送中断服务函数，表示发送数据完毕
****************************************************************************/
#ifdef NAND_DMA_ACCESS
void DMA1_Channel1_IRQHandler(void)
{
	OSIntEnter();	  
	if(DMA_GetFlagStatus(DMA1_FLAG_TC1)) //Modify
	{
		DMA_Cmd(DMA1_Channel1, DISABLE);	//除能DMA通道                
		OSSemPost(m_pNandDMASyncEvent);
	}
	DMA_ClearFlag(DMA1_FLAG_GL1| DMA1_FLAG_TC1 | DMA1_FLAG_HT1 | DMA1_FLAG_TE1);  //Modify

	OSIntExit();
}
#endif


/****************************************************************************
* 名	称：FlashWrite()
* 功	能：M25P80写函数
* 入口参数：pdat 待写入数据的指针；nStartAddr flash中的起始地址；
			nlen 待写入数据的长度
* 出口参数：无
* 说	明：无
****************************************************************************/
static uint32 nPrePageIndex = 0xFFFFFFFF;
void FlashWrite(uint8* pdat, uint32 nStartAddr, uint32 nlen) reentrant
{
#ifdef NAND_DMA_ACCESS

	NAND_ADDRESS Address;
	u32 addressstatus = NAND_VALID_ADDRESS;
	u32 status = NAND_READY;
	u32 NumPageToWrite;
	u32 nWriteLen;
	int nPage;
	u8 nCommErr;	 

	if(nlen <= 0) return;

	nPage = nStartAddr / NAND_PAGE_SIZE;
	
	//更新读缓冲
	if(nPrePageIndex == nPage)
	{
		nPrePageIndex = 0xFFFFFFFF;
	}

	Address.Zone = 0;
	Address.Block = nPage / NAND_BLOCK_SIZE;
	Address.Page  = nPage % NAND_BLOCK_SIZE;
	
	
	NumPageToWrite =  (nlen % NAND_PAGE_SIZE != 0) ? (nlen  / NAND_PAGE_SIZE + 1) : (nlen / NAND_PAGE_SIZE);
	
	
	while((NumPageToWrite != 0x00) && (addressstatus == NAND_VALID_ADDRESS) && (status == NAND_READY))
	{
	    //设置写Flash地址，注意，开始地址始终页对齐！！！
		*(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE0;
	
	    *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
	    *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0X00;
	    *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
	    *(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);

		//计算页内长度
		nWriteLen = (nlen > NAND_PAGE_SIZE) ? NAND_PAGE_SIZE : nlen;
		
	    //设置DMA操作
		DMA1_Channel1->CMAR = (uint32)pdat;
		DMA1_Channel1->CNDTR = nWriteLen;
		DMA1_Channel1->CCR |= DMA_DIR_PeripheralDST; 	
		DMA_Cmd(DMA1_Channel1, ENABLE);	

		//等待DMA操作完成
	    OSSemPend(m_pNandDMASyncEvent, 0, &nCommErr);

		//更新写区域
		pdat += nWriteLen;
		nlen -= nWriteLen;
	    
		//
	    *(vu8 *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_WRITE_TRUE1;
	
	    //获取NandFlash状态
		status = FSMC_NAND_GetStatus();
	    

	    if(status == NAND_READY)
	    {
			NumPageToWrite--;
			
			//设置下一页
			addressstatus = FSMC_NAND_AddressIncrement(&Address);    
	    }    
	}
  
#else	

	int i;//, nIndex;
	NAND_ADDRESS addr;
#if OS_CRITICAL_METHOD == 3  
	OS_CPU_SR  cpu_sr = 0;
#endif
	addr.Zone = 0;
	addr.Block = nStartAddr / NAND_PAGE_SIZE / NAND_BLOCK_SIZE;
	addr.Page  = (nStartAddr / NAND_PAGE_SIZE) % NAND_BLOCK_SIZE;
	if(nlen < NAND_PAGE_SIZE)
	{
		for(i=0; i < nlen; i++)   //填充Buf
			NandBuff[i] = pdat[i];
		OS_ENTER_CRITICAL(); 
		FSMC_NAND_WriteSmallPage(NandBuff, addr, 1);	     //写一页 
		OS_EXIT_CRITICAL();
	}
	else
	{
		OS_ENTER_CRITICAL(); 
		FSMC_NAND_WriteSmallPage(pdat, addr, 1);	     //写一页 
		OS_EXIT_CRITICAL();
	}
#endif

}

/****************************************************************************
* 名	称：FlashRead()
* 功	能：M25P80读函数
* 入口参数：pdat 待读出数据的指针；nStartAddr flash中的起始地址；
			nlen 待读出数据的长度
* 出口参数：无
* 说	明：无
****************************************************************************/
void FlashRead(uint8* pdat, uint32 nStartAddr, uint32 nlen) reentrant
{
//#ifdef NAND_DMA_ACCESS
#if 0
	NAND_ADDRESS Address;
	u32 addressstatus = NAND_VALID_ADDRESS;
	u32 NumPageToRead;
	u8 nCommErr;

	if(nlen <= 0)
		return;

	Address.Zone = 0;
	Address.Block = nStartAddr / NAND_PAGE_SIZE / NAND_BLOCK_SIZE;
	Address.Page  = (nStartAddr / NAND_PAGE_SIZE) % NAND_BLOCK_SIZE;
	NumPageToRead =  nlen % NAND_PAGE_SIZE ? nlen  / NAND_PAGE_SIZE + 1 : NAND_PAGE_SIZE / nlen; 

	while((NumPageToRead != 0x0) && (addressstatus == NAND_VALID_ADDRESS))
	{	   
		/* Page Read command and page address */
		*(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_A;
		
		*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0x00;
		*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = 0X00;
		*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_1st_CYCLE(ROW_ADDRESS);
		*(__IO uint8_t *)(Bank_NAND_ADDR | ADDR_AREA) = ADDR_2nd_CYCLE(ROW_ADDRESS);
		
		*(__IO uint8_t *)(Bank_NAND_ADDR | CMD_AREA) = NAND_CMD_AREA_TRUE1;
		
		 /* 必须等待，否则读出数据异常 */
		 while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
		
		/* Get Data into Buffer */    
		DMA1_Channel1->CMAR = (uint32)pdat;
		DMA1_Channel1->CNDTR = NAND_PAGE_SIZE;
		DMA1_Channel1->CCR |= DMA_DIR_PeripheralSRC; 	
		DMA_Cmd(DMA1_Channel1, ENABLE);	

	    OSSemPend(m_pNandDMASyncEvent, 0, &nCommErr);
    
		NumPageToRead--;

		/* Calculate page address */           			 
		addressstatus = FSMC_NAND_AddressIncrement(&Address);
	}

#else


	uint32 nPageIndex;
	uint32 nSaddr;
	uint32 nCopyLen;
	BOOL bUseBuff;
	NAND_ADDRESS Address;

	if(nlen <= 0) return;


	nPageIndex = nStartAddr / NAND_PAGE_SIZE;
	Address.Zone = 0;
	Address.Block = nPageIndex / NAND_BLOCK_SIZE;
	Address.Page  = nPageIndex % NAND_BLOCK_SIZE;

	nSaddr = nStartAddr % NAND_PAGE_SIZE;
	while(1)
	{
		bUseBuff = TRUE;
		
		if(nPrePageIndex != nPageIndex)
		{
			if((nSaddr == 0) && (nlen >= NAND_PAGE_SIZE))
			{
				FSMC_NAND_ReadSmallPage(pdat, Address, 1);
				pdat += NAND_PAGE_SIZE;
				nlen -= NAND_PAGE_SIZE;
				bUseBuff = FALSE;
			}
			else
			{
				FSMC_NAND_ReadSmallPage(NandBuff, Address, 1);
				nPrePageIndex = nPageIndex;

				bUseBuff = TRUE;	  				
			}				
		}

		if(bUseBuff == TRUE)
		{
			nCopyLen = NAND_PAGE_SIZE - nSaddr;
			if(nCopyLen > nlen) nCopyLen = nlen;
			
			memcpy(pdat, NandBuff + nSaddr, nCopyLen);
			pdat += nCopyLen;
			nlen -= nCopyLen;
		}

		if(nlen == 0) break;

		//执行下一次
		FSMC_NAND_AddressIncrement(&Address);
		nSaddr = 0;
		nPageIndex++;
	}


#endif
}

/****************************************************************************
* 名	称：FlashErase()
* 功	能：M25P80擦除函数
* 入口参数：Select 擦除类型；Addr 待擦除的段起始地址
* 出口参数：无
* 说	明：无
****************************************************************************/
void FlashErase(uint32 Addr, uint32 nLen) reentrant
{
	uint32 nBlockSize, nEraseSize;
	NAND_ADDRESS addr;
	addr.Zone = 0;
	addr.Block = Addr / NAND_PAGE_SIZE / NAND_BLOCK_SIZE;
	addr.Page  = (Addr / NAND_PAGE_SIZE) % NAND_BLOCK_SIZE;

	nBlockSize = NAND_BLOCK_SIZE * NAND_PAGE_SIZE;
	do
	{
	    FSMC_NAND_EraseBlock(addr);
		nEraseSize = addr.Block * nBlockSize - Addr;
		nLen -= nEraseSize;
		Addr = 0;
		addr.Block++;
	}while(nLen > nEraseSize);

}

/****************************************************************************
* 名	称：FlashBusy()
* 功	能：M25P80忙判断函数
* 入口参数：无
* 出口参数：1 忙；0 空闲
* 说	明：无
****************************************************************************/
#ifdef _FLASH_BUSY_
BOOL FlashBusy()  reentrant
{
	BOOL bBusy;
#ifdef _FLASH_M25P80_H_
	BOOL bBusy;
	uint8 Result;

	EA = 0;EA = 0;
	
	//读状态寄存器
	FlashEnable();
	spi_rw(RDSR);
	Result = spi_rw(0xFF);
	FlashDisable();
	EA = 1;EA = 1;

	//获取状态位
	bBusy = Result & 0x01;
	return bBusy;
#endif	 //_FLASH_M25P80_H_
	bBusy = FSMC_NAND_ReadStatus() == NAND_BUSY ? 0 : 1;
	return bBusy;
}
#endif


#ifdef	_FALSH_TEST_

//************************************************************
//功能描述：M25P80测试程序，将数据写入M25P80，然后读出，
//			看读写数据是否一致
//测试平台：桥测采集器V3.0

//说    明：如果读写有异常，首先检查读写时钟的频率是否过高
//************************************************************

void FlashCheck() reentrant
{
	uint16 i, nEndCheck = 0;

	//清空Flash
	FlashErase(0);
												 
	//擦除某一扇区
	//FlashErase(SE,0x00000);

	//将数据区清零
	for(i=0;i<nDataLen;i++) WriteBuff[i] = i;

	//开始循环读写数据
	FlashAddr = 0;
	while(1)
	{	
		//地址保护，防止读写越界
		if(FlashAddr+nDataLen > MOSTADDR)
		{
			nEndCheck = 1;
			nDataLen = MOSTADDR - FlashAddr;
		}
		
		//将数据写入Flash
		FlashWrite(WriteBuff,FlashAddr,nDataLen);

		//将Flash数据读出
		FlashRead(NandBuff,FlashAddr,nDataLen);
	
		//校验数据
		for(i=0;i<nDataLen;i++)
		{
			if(WriteBuff[i] != NandBuff[i]) break;
		}

		//判断
		if(i == nDataLen)
		{
			if(nEdnCheck)
				break;
			//更新待写数据
			for(i=0;i<nDataLen;i++) WriteBuff[i] += 1;
			//Flash读写地址更新
			FlashAddr += nDataLen;
		}
		else
		{
			ErrorAddr = FlashAddr;
			while(1)					//停止读写
			{
				//读写出错的地方
				_nop_();				//For break point
			}
		}
		//判断是否整个Flash已写完
		if(FlashAddr >= MOSTADDR)
		{
			while(1)					//停止读写
			{
				_nop_();				//For break point
			}
		}
	}
//#endif	 //_FLASH_M25P80_H_
	//
}
#endif
